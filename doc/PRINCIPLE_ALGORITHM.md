# Tic-tac 计算原理与算法详解

## 1. 引言：三体问题与Faddeev方程

### 1.1 物理问题

在核物理中，精确描述三个核子（如两个质子和一个中子，或一个质子和两个中子）的系统是一个经典的挑战，被称为“三体问题”。与二体问题（例如，氘核）可以通过求解薛定谔方程得到精确解不同，直接使用单一的薛定谔方程处理三体相互作用会导致数学上的困难。其根本原因在于，三体系统的渐进行为（当粒子间距离趋于无穷大时）非常复杂，可能包含一个自由粒子和一个束缚对、三个自由粒子等多种情况，单一的波函数难以正确处理这些不同的边界条件。

### 1.2 Faddeev 方程

**Ludvig Faddeev** 在20世纪60年代提出了一套严谨的数学框架来解决这个问题。其核心思想是将一个复杂的总波函数 $\Psi$ 分解为三个分量（Faddeev 分量）$\psi_1, \psi_2, \psi_3$ 的和：

$$ \Psi = \psi_1 + \psi_2 + \psi_3 $$

每个分量 $\psi_i$ 描述了当粒子对 $(j,k)$ ($i,j,k$ 是 1,2,3 的一个轮换) 发生最后一次相互作用时的系统状态。这种分解方式的巧妙之处在于，它将一个单一的、具有复杂边界条件的薛定谔方程，转化为了一个耦合的、但每个方程边界条件都更清晰的方程组，即 **Faddeev 方程**：

$$
\begin{align*}
\psi_1 &= \phi_1 + G_0(E) T_1 (\psi_2 + \psi_3) \\
\psi_2 &= \phi_2 + G_0(E) T_2 (\psi_3 + \psi_1) \\
\psi_3 &= \phi_3 + G_0(E) T_3 (\psi_1 + \psi_2)
\end{align*}
$$

其中：
- $\phi_i$ 是 **初始状态**，在散射问题中，它通常描述一个自由粒子 $i$ 和一个由 $(j,k)$ 组成的束缚对（例如，一个中子入射到氘核上）。如果系统能量不足以形成束缚对，则此项为零。
- $G_0(E) = (E - H_0)^{-1}$ 是自由系统的 **格林函数**（Green's function）或传播子。它描述了在总能量为 $E$ 时，三个粒子在没有相互作用的情况下如何从一个状态演化到另一个状态。$H_0$ 是自由动能算符。
- $T_i = V_i + V_i G_0(E) T_i$ 是 **二体 T-矩阵**，它描述了粒子对 $(j,k)$ 之间在三体系统环境中的完整相互作用。它与二体相互作用势 $V_i$ 通过 Lippmann-Schwinger 方程相关联。

`Tic-tac` 代码的核心目标就是数值求解这个方程组，以获得总波函数 $\Psi$，并从中提取出可观测量（如散射截面、极化等）。

## 2. 核心算法与实现

### 2.1 动量空间与分波展开

#### 原理

为了求解 Faddeev 方程，我们通常不在坐标空间中直接处理，而是转换到 **动量空间**。这有几个好处：
1.  动能算符 $H_0$ 从一个微分算符（$-\frac{\hbar^2}{2m}\nabla^2$）变成一个简单的代数表达式（$p^2/2m$），大大简化了计算。
2.  散射问题中的渐进边界条件在动量空间中表现为波函数在特定动量值上的奇异性（奇点），处理起来更方便。

在动量空间中，三体系统的状态由两个 **雅可比动量**（Jacobi momenta）$\vec{p}$ 和 $\vec{q}$ 描述：
- $\vec{p}$：描述子系统（例如粒子2和3）的相对动量。
- $\vec{q}$：描述粒子1相对于子系统（粒子2和3）质心的动量。

然而，$\vec{p}$ 和 $\vec{q}$ 仍然是矢量，包含角度依赖性。为了进一步简化，我们使用 **分波展开**（Partial Wave Expansion）。这意味着我们将波函数和算符展开为一系列具有确定量子数的“通道”（channels）的叠加。每个通道都具有：
- 确定的总角动量 $J$ 及其投影 $M$。
- 确定的宇称 $\pi$。
- 确定的总同位旋 $T$。
- 以及内部的轨道和自旋角动量，如 $L_{2N}$ (核子对的轨道角动量), $S_{2N}$ (核子对的自旋), $L_{1N}$ (第三个核子相对于核子对的轨道角动量) 等。

经过分波展开后，原本复杂的矢量方程就变成了一系列耦合的、只依赖于动量大小 $p$ 和 $q$ 的标量积分方程。

#### 代码实现

-   **`type_defs.h`**: 定义了存储分波态量子数的结构体，如 `pw_3N_state`。
-   **`make_pw_symm_states.cpp`**:
    -   `construct_3N_pw_states()` 函数是核心。它通过嵌套循环遍历所有可能的角动量和同位旋量子数。
    -   在循环中，它会检查这些量子数是否满足角动量耦合规则和泡利不相容原理（例如，对于两个核子，$L+S+T$ 必须是奇数）。
    -   **近似与边界**: 这里的关键近似是 **截断**。我们不可能包含无穷多的分波态。代码通过两个输入参数来限制基空间的大小：
        -   `J_2N_max`: 核子对的最大总角动量。
        -   `two_J_3N_max`: 三核子系统的最大总角动量（的2倍）。
        所有超过这些限制的通道都会被忽略。这是一个物理近似，其合理性取决于所研究的能量：能量越高，需要包含的角动量就越大。

### 2.2 置换算符 $P$

#### 原理

由于三个核子是全同费米子，它们的总波函数 $\Psi$ 必须在任意两个粒子交换时反对称。利用这个对称性，我们可以将三个耦合的 Faddeev 方程简化为一个单一的方程：

$$ \psi_1 = \phi_1 + G_0(E) T_1 (P_{12}P_{23} + P_{13}P_{23}) \psi_1 $$

这里 $P_{ij}$ 是交换粒子 $i$ 和 $j$ 的算符。组合算符 $P \equiv P_{12}P_{23} + P_{13}P_{23}$ 被称为 **置换算符**。它将粒子进行循环置换（$1 \to 2 \to 3 \to 1$）和反循环置换。

在分波展开的基矢下，这个算符变成一个巨大的矩阵，我们称之为 `P123` 矩阵。它的矩阵元 $\langle \alpha' p' q' | P | \alpha p q \rangle$ 表示一个处于分波态 $\alpha$、动量为 $(p,q)$ 的系统，在经过粒子置换后，投影到态 $\alpha'$、动量为 $(p',q')$ 上的概率幅。

这个计算极其复杂，因为它涉及到：
1.  从一个雅可比坐标系到另一个的几何变换。
2.  复杂的角动量重耦合（Recoupling），需要计算大量的 Wigner 6-j 和 9-j 符号。

#### 代码实现

-   **`make_permutation_matrix.cpp`**: 这个模块专门用于计算 `P123` 矩阵。
    -   `calculate_permutation_elements_for_3N_channel()` 是核心函数。
    -   **角动量重耦合**: 函数内部会调用 GSL 库（GNU Scientific Library）来计算 Wigner 系数，这是角动量代数的核心。
    -   **几何变换**: 粒子动量的变换导致了复杂的几何积分。这些积分通过高斯勒让德求积进行数值计算。
        -   **近似与边界**: 积分的精度由 `Nphi` 和 `Nx` 两个参数控制，它们分别定义了方位角和极角积分的求积点数。点数越多，结果越精确，但计算时间也越长。
    -   **并行计算**: `P123` 的计算是 embarrassingly parallel 的。代码使用 OpenMP (`#pragma omp parallel for`) 将不同 $(p,q)$ 和 $(\alpha)$ 组合的计算任务分配到多个 CPU 核心上，大大缩短了计算时间。线程数由 `P123_omp_num_threads` 参数控制。
    -   **稀疏存储**: `P123` 矩阵是高度稀疏的（大部分元素为零）。代码采用 COO (Coordinate list) 格式存储非零元素，即只保存非零值的（行、列、数值）三元组。这极大地节省了内存。
    -   **HDF5 存储**: 由于 `P123` 计算非常耗时，计算完成后，结果会以 HDF5 (Hierarchical Data Format 5) 格式保存在磁盘上（文件名如 `P123_sparse_...h5`）。在后续的计算中，如果参数匹配，程序会直接从文件中读取 `P123`，避免重复计算。

### 2.3 波包离散化 (Wave Packet Discretization)

#### 原理

动量 $p$ 和 $q$ 是连续变量，但在计算机中必须进行离散化处理。一种简单的方法是使用标准的求积网格（如高斯勒让德求积）。然而，这种方法在处理 T-矩阵和格林函数中的奇异点时效率不高。

`Tic-tac` 采用了一种更先进的技术，称为 **波包（Wave Packet, WP）** 方法。其思想是：
1.  将连续的动量轴（$p$ 和 $q$）分割成若干个不重叠的区间（bins）。
2.  在每个区间内，定义一个归一化的“波包”函数。这些波包函数构成了我们的离散基矢。

这种方法的好处是，我们可以通过对二体哈密顿量进行对角化来构造这些波包，使得它们能够很好地描述系统的物理特性。这些特殊的波包被称为 **散射波包（Scattering Wave Packets, SWP）**。在一个给定的能量区间（bin）内，通过求解二体薛定谔方程，我们可以得到一组正交的解，这些解就是这个区间的 SWP 基矢。这个过程相当于在每个动量区间内预先对角化了二体 T-矩阵，极大地简化了最终的三体问题。

#### 代码实现

-   **`make_wp_states.cpp`**:
    -   `construct_WP_p_boundaries()` 和 `construct_WP_q_boundaries()`: 根据用户选择的网格类型（如 `chebyshev`）来确定动量区间的边界。Chebyshev 分布的特点是在低动量区更密集，高动量区更稀疏，这符合核物理中相互作用主要集中在低能区的特点。
        -   **近似与边界**: 区间的数量由 `Np_WP` 和 `Nq_WP` 控制，这是最关键的离散化近似。区间越多，对连续动量的描述越精确。
-   **`make_swp_states.cpp`**:
    -   `construct_2N_SWPs()`: 这是构造散射波包的核心。
    -   对于每个二体通道（如 `1S0`, `3S1-3D1` 等）和每个动量区间，代码会：
        1.  构造二体哈密顿量矩阵 $H_{2N} = T_{rel} + V_{2N}$。
        2.  调用 LAPACK 库中的 `LAPACKE_dspevd` 函数对该矩阵进行对角化，求出其本征值（能量）和本征向量。
        3.  这些本征向量就是该区间的 SWP 基矢。
    -   **近似与边界**: 在每个区间内部，哈密顿量矩阵是通过高斯勒让德求积来计算的。求积点数由 `Np_per_WP` 和 `Nq_per_WP` 控制，影响了 SWP 基矢本身的精确度。

### 2.4 求解线性方程组

#### 原理

经过分波展开和波包离散化后，Faddeev 积分方程最终变成一个大型的复数线性方程组：

$$ (I - A)x = b $$

其中：
- $x$ 是我们要求解的未知向量，代表了在离散基（分波通道 $\times$ 动量波包）上的 Faddeev 分量 $\psi_1$。
- $b$ 是初始状态向量 $\phi_1$ 在离散基上的表示。
- $A = G_0 T_1 P$ 是描述系统演化的巨大矩阵，通常被称为 **Faddeev 核（Kernel）**。

由于矩阵 $A$ 的维度可以达到几十万甚至上百万，直接求逆 $(I-A)^{-1}$ 在计算上是不可行的。因此，代码采用了 **迭代法** 来求解。`Tic-tac` 使用的是一种 **Krylov 子空间方法**，很可能是 GMRES (Generalized Minimal RESidual method)。其基本思想是：
1.  从一个初始猜测 $x_0$ 开始（例如 $x_0 = b$）。
2.  构造一个由 $\{b, Ab, A^2b, \dots, A^k b\}$ 张成的子空间（Krylov 子空间）。
3.  在这个子空间中寻找一个近似解 $x_k$，使得残差 $\|b - (I-A)x_k\|$ 最小。
4.  不断扩大子空间（增加 $k$），重复此过程，直到残差小于指定的容差 `tolerance`。

#### 代码实现

-   **`solve_faddeev.cpp`**:
    -   `solve_faddeev_equation()`: 实现了迭代求解过程。
    -   **核心操作**: 迭代求解的关键是高效地计算矩阵-向量乘积 $y = A x$。代码中并没有显式地构造出巨大的矩阵 $A$，而是实现了一个函数，当给定一个向量 $x$ 时，它能计算出 $A$ 作用于 $x$ 后的结果 $y$。这个过程依次包含了置换矩阵 $P$ 的乘法、T-矩阵 $T_1$ 的乘法（在 SWP 基下是对角阵，所以很简单）和格林函数 $G_0$ 的乘法（也是对角阵）。
    -   **收敛条件**: 迭代的停止条件由 `run_params.faddeev_tolerance` 参数控制。这是一个重要的数值近似，它决定了解的精确度。容差越小，解越精确，但需要的迭代次数也越多。
    -   **调试模式**: `solve_dense` 参数允许使用 LAPACK 的 `zgesv` 直接求解，但这仅在基空间非常小（例如 `Np_WP`*`Nq_WP`*`N_channels` < 1000）时才可行，主要用于验证迭代求解器的正确性。

### 2.5 数值库的使用总结

为了实现上述算法，代码高度依赖于标准的高性能数值库：
-   **BLAS (Basic Linear Algebra Subprograms)**: 用于执行底层的矩阵-向量和矩阵-矩阵乘法（例如 `cblas_zgemm`）。这在迭代求解过程中计算矩阵-向量乘积时至关重要。
-   **LAPACK/LAPACKE (Linear Algebra PACKage)**: 用于执行更高级的线性代数运算。
    -   `LAPACKE_zgetrf`/`zgetrs`: 执行 LU 分解并求解线性系统，用于 `solve_dense` 调试模式。
    -   `LAPACKE_dspevd`: 对角化实对称矩阵，用于在 `make_swp_states.cpp` 中构造散射波包（SWP）。
-   **GSL (GNU Scientific Library)**: 用于计算各种特殊函数，特别是 `gsl_sf_coupling_6j` 和 `gsl_sf_coupling_9j`，这些是计算置换矩阵 `P123` 时进行角动量重耦合所必需的。

从 Intel MKL 迁移到通用的 `openblas`/`lapacke` 意味着将原先对 MKL 特定函数的调用替换为这些标准库提供的等效函数。幸运的是，LAPACKE 提供了与 MKL 几乎一致的 C 语言接口，使得这种迁移相对直接。主要的挑战在于确保编译和链接阶段能正确找到并链接这些通用库。

